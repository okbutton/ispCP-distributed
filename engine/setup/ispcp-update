#!/usr/bin/perl

# ispCP ω (OMEGA) a Virtual Hosting Control Panel
# Copyright (C) 2006-2009 by isp Control Panel - http://ispcp.net
#
# Version: $Id$
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is "ispCP ω (OMEGA) a Virtual Hosting Control Panel".
#
# The Initial Developer of the Original Code is ispCP Team.
# Portions created by Initial Developer are Copyright (C) 2006-2009 by
# isp Control Panel. All Rights Reserved.
#
# The ispCP ω Home Page is:
#
#    http://isp-control.net
#

#
# Special note for DevTeam:
#
# It is necessary for the error recovery and update procedures that the scripts
# be idempotent. This means that if it is run successfully, and then it is called
# again, it doesn't bomb out or cause any harm, but just ensures that everything
# is the way it ought to be. If the first call failed, or aborted half way through for
# some reason, the second call should merely do the things that were left undone
# the first time, if any, and exit with a success status if if everything is OK.
#
# This is an important point since the successive execution of the script should
# allow the user to generate configuration files related to services that were not
# activated during the last invocation (eg. awstats).

#
## WARNING : Thas is the new version of ispcp-update script.
## No test has yet been made !
#

use FindBin;
use lib "$FindBin::Bin/..";

require 'ispcp_common_code.pl';
require 'ispcp-setup-methods.pl';

# FIXME: Check if it ok for all dist
use Term::ReadKey;

# Todo Added this package (ex. debian: libfile-mimeinfo-perl)
use File::MimeInfo::Magic;

use Term::ANSIColor qw(:constants);
$Term::ANSIColor::AUTORESET = 1;

use strict;
use warnings;

# User entries
%main::ua = ();

# Reassigned here to avoid 'used only once: possible typo warning'
$main::cfg_re = '^[ \t]*([\_A-Za-z0-9]+) *= *([^\n\r]*)[\n\r]';
@main::db_connect = ();

#
## Subroutines - Begin
#

# Start the update process
sub update_startup {

	push_el(\@main::el, 'update_startup()', 'Starting...');

	# FIXME: PM Joxi
	if(-e '/tmp/ispcp-backup-all.lock')
	{
		exit_msg('Backups engine is currently running. Aborting...');
	}

	push_el(\@main::el, 'update_startup()', 'Ending...');

	0;
}

# Performs all update tasks
sub update_engine {

	push_el(\@main::el, 'update_engine()', 'Starting...');

	my $rs = undef;

	# User dialog
	user_dialog();

	system('clear');

	# Stopping services
	print STDOUT "\n\tStopping Services:";
	$rs = stop_services();
	exit_msg('Failed!', $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 35);

	# Starting Pre installation script if it exists
	if(-e "$main::cfg{'ROOT_DIR'}/engine/setup/preinst")
	{
		print STDOUT "\n\tStarting Preinstallation / update script:";
		$rs = preinst('update');
		exit_msg('Failed!', $rs) if($rs != 0);
	}

	#
	## IspCP main configuration file - Begin
	#

	print STDOUT BOLD "\n\tIspCP main configuration file\n";

	# Loading old ispCP configuration file
	print STDOUT "\t Loading old ispCP configuration file:";
	$rs = load_old_ispcp_cfg();
	exit_msg('Failed!', $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 46);

	# Update ispCP configuration file
	print STDOUT "\t Update ispCP configuration file:";
	$rs = update_ispcp_cfg();
	exit_msg('Failed!', $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 41);

	#
	## IspCP main configuration file - End
	#

	#
	## IspCP database - Begin
	#

	print STDOUT BOLD "\n\tIspCP database\n";

	# Update IspCP database schema
	print STDOUT "\t Update IspCP database schema:";
	$rs = update_database_schema();
	exit_msg('Failed!', $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 38);

	#
	## IspCP database - End
	#

	#
	## IspCP Services configuration files - Begin
	#

	# Rebuilding all services configuration files
	print STDOUT BOLD "\n\tRebuilding all services configuration files\n";
	$rs = rebuild_services_cfg();
	exit_msg('Failed!', $rs) if($rs != 0);

	#
	## IspCP Services configuration files - End
	#

	#
	## IspCP gui configuration files - Begin
	#

	# Rebuilding all gui related configuration files
	print STDOUT BOLD "\n\tRebuilding all gui configuration files\n ";
	$rs = rebuild_gui_cfg();
	exit_msg('Failed!', $rs) if($rs != 0);

	#
	## IspCP gui configuration files - End
	#

	#
	## IspCP customers configuration files - Begin
	#

	# Rebuilding all customers configuration files
	print STDOUT BOLD "\n\tRebuilding all customers configuration files";
	print STDOUT "\n\tPlease wait, this can take time:";
	$rs = rebuild_customers_cfg();
	exit_msg('Failed!', $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 40);

	#
	## IspCP customers configuration files - End
	#

	#
	## IspCP files permissions - Begin
	#

	# Set engine and gui permissions
	print STDOUT BOLD "\n\tSet engine and gui permission\n";
	$rs = set_permissions();
	exit_msg('Failed!', $rs) if($rs != 0);

	#
	## IspCP files permissions - End
	#

	# Starting services
	print STDOUT "\n\tStarting services:";
	$rs = start_services();
	exit_msg('Failed!', $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 35);

	# Starting Post installation script if it exists
	if(-e "$main::cfg{'ROOT_DIR'}/engine/setup/postinst")
	{
	print STDOUT "\n\tStarting post installation / update script:";
	$rs = postinst('update');
	exit_msg('Failed!', $rs) if($rs != 0);
	}

	push_el(\@main::el, 'update_engine()', 'Ending...');

	0;
}

# Shutdown update process
sub update_shutdown {

	push_el(\@main::el, 'update_shutdown()', 'Starting...');

	my $rs = setup_cleanup();
	return $rs if($rs != 0);

	my $shut_down_message = <<MSG;

\tCongratulations!

\tispCP '$main::cfg{'Version'}' Update completed successfully!

\tPlease type http://$main::cfg{'BASE_SERVER_VHOST'} in your browser.

MSG

	print STDOUT $shut_down_message;

	push_el(\@main::el, 'update_shutdown()', 'Ending...');

	0;
}

# Exit with an optionnal error message
sub exit_msg {

	push_el(\@main::el, 'exit_msg()', 'Starting...');

	my ($msg, $code) = @_;

	if (!defined($code) || $code <= 0 )
	{
		$code = 1;
	}

	if (defined($msg) && $msg ne '' )
	{
		if($msg eq 'Failed!')
		{
			print STDERR BOLD RED "$msg\n";
		}
		else
		{
			print STDERR "\t$msg\n";
		}
	}

	push_el(\@main::el, 'exit_msg()', 'Ending...');

	exit $code;
}

# User dialog
sub user_dialog {

	push_el(\@main::el, 'user_dialog()', 'Starting...');

	welcome_note();

	warn_msg();

	push_el(\@main::el, 'user_dialog()', 'Ending...');

	0;
}

# Welcome note
sub welcome_note {

	push_el(\@main::el, 'welcome_note()', 'Starting...');

	my $rdata = undef;

	# Clear screen
	system('clear');

	my $welcome_message =
		"\tWelcome to ispCP '$main::cfg{'Version'}' Update Dialog.\n".
		"\tThis program will update your ispCP OMEGA system on your server.\n".
		"\tPlease make sure you have a backup of your server data.\n\n".

		"\tNOTE: During the migration process some or all services might require to be\n".
		"\tshut down.\n\n".

		"\tWarning: Only services that are not marked as 'NO' in your configuration file\n".
		"\twill be processed by this program.\n\n";

	print STDOUT $welcome_message;

	do
	{
		print STDOUT "\tDo you want to continue [Y/n]: ";
		chomp($rdata = readline \*STDIN);

	} while($rdata !~ /^(|y|n)$/i);

	exit 0 if($rdata =~ /n/i);

	push_el(\@main::el, 'welcome_note()', 'Ending...');

	0;
}

# Warn message
sub warn_msg {

	push_el(\@main::el, 'warn_msg()', 'Starting...');

	my $rdata = undef;

	my $warning =
		"\tMake sure you have read and performed all steps from docs/distro/INSTALL\n".
		"\tdocument.\n\n";

	system 'clear';

	print STDOUT $warning;

	do
	{
		if(defined $rdata && $rdata eq '?')
		{
			print STDOUT "\n\tOrders:\n".
  				"\t\ty : Continue to update\n".
  				"\t\tn : Abort and exit\n".
  				"\t\ts : Select a specific task to perform (Not yet implemented)\n\n";
		}

		print STDOUT "\tDo you want to continue [Y/n/?]: ";
		chomp($rdata = readline \*STDIN);

	} while($rdata !~ /^(|n|y)$/i);

	exit 0 if($rdata =~ /n/i);

	push_el(\@main::el, 'warn_msg()', 'Ending...');

	0;
}
# Starting services
sub start_services {

	push_el(\@main::el, 'start_services()', 'Starting...');

	foreach(
		qw/CMD_ISPCPN CMD_ISPCPD
		CMD_NAMED
		CMD_HTTPD CMD_FTPD
		CMD_MTA CMD_AUTHD
		CMD_POP CMD_POP_SSL
		CMD_IMAP CMD_IMAP_SSL/
	)
	{
		if( $main::cfg{$_} !~ /no/i && -e $main::cfg{$_})
		{
			sys_command("$main::cfg{$_} start &>/dev/null");
			print STDOUT BOLD BLACK '.';
			sleep 1;
		}
	}

	push_el(\@main::el, 'start_services()', 'Ending...');

	0;
}

# Stopping services
# Stop all service who are marked as 'no' in ispcp.conf
sub stop_services {

	push_el(\@main::el, 'stop_services()', 'Starting...');

	foreach(
		qw/CMD_ISPCPN CMD_ISPCPD
		CMD_NAMED
		CMD_HTTPD CMD_FTPD
		CMD_MTA CMD_AUTHD
		CMD_POP CMD_POP_SSL
		CMD_IMAP CMD_IMAP_SSL/
	)
	{
		if( $main::cfg{$_} !~ /no/i && -e $main::cfg{$_})
		{
			sys_command("$main::cfg{$_} stop &>/dev/null");
			print STDOUT BOLD BLACK '.';
			sleep 1;
		}
	}

	push_el(\@main::el, 'stop_services()', 'Ending...');

	0;
}

# Load old ispCP main configuration file
sub load_old_ispcp_cfg {

	push_el(\@main::el, 'load_old_ispcp_config()', 'Starting...');

	my ($rs, $old_ispcp_cfg_file) = (undef, '/etc/ispcp/ispcp.old.conf');

	if (get_conf($old_ispcp_cfg_file))
	{
		do
		{
			print STDOUT "\tPlease enter path to your ispcp.old.conf [/etc/ispcp/ispcp.old.conf]: ";

			chomp($old_ispcp_cfg_file = readline \*STDIN);

		} while (get_conf($old_ispcp_cfg_file));
	}

	$main::ua{'old_cfg_file'} = $old_ispcp_cfg_file;

	push_el(\@main::el, 'load_old_ispcp_config()', 'Ending...');

	0;
}
# Update ispCP main configuration file
sub update_ispcp_cfg {

	push_el(\@main::el, 'update_ispcp_config()', 'Starting...');

	my ($rs, $rdata) = (undef, undef);

	# Loading old ispCP configuration file as a string
	($rs, $rdata) = get_file($main::ua{'old_cfg_file'});
	return $rs if($rs != 0);

	# Loading new configuration from /etc/ispcp/ispcp.conf
	$rs = get_conf();
	return $rs if($rs != 0);

	# For each cfg line
	foreach(map{$$_."\n"} \split(/\n/, $rdata))
	{
		if(/$main::cfg_re/ && $1 !~/^BuildDate|Version|CodeName$/)
		{
			# If the old configuration key still exists in the new file
			# and its value is different from existing
			if(defined($main::cfg{$1}) && $main::cfg{$1} ne $2 )
			{
				# We restore old value
				$rs = set_conf_val($1, $2);
				return $rs if ($rs != 0);
			}
		}
	}

	# Store the updated configuration in /etc/ispcp/ispcp.conf and reload it
	# at the same time
	$rs = store_conf();
	return $rs if ($rs != 0);

	push_el(\@main::el, 'update_ispcp_config()', 'Ending...');

	0;
}

# Update ispCP database schema
sub update_database_schema {

	push_el(\@main::el, 'update_database_schema()', 'Starting...');

	my ($rs, $cmd, $php) = (undef, undef, undef);

	$main::db_pwd =~ s/([\'\"])/\\$1/g;

	$cmd = "$main::cfg{'CMD_PHP'} $main::cfg{'ROOT_DIR'}/engine/setup/updDB.php $main::cfg{'GUI_ROOT_DIR'} $main::db_user $main::db_pwd $main::db_name $main::db_host &>/dev/null";
	$rs = sys_command_rs($cmd);
	return $rs if($rs !=0);

	push_el(\@main::el, 'update_database_schema()', 'Ending...');

	0;
}
# Rebuilding all services configuration files
sub rebuild_services_cfg {

	push_el(\@main::el, 'rebuild_services_config()', 'Starting...');

	my $rs = undef;

	print STDOUT "\t IspCP Crontab file:";
	$rs = setup_crontab();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 28);

	print STDOUT "\t IspCP Named main configuration file:";
	$rs = setup_named();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 45);

	print STDOUT "\t IspCP php (fastCGI modules configuration):";
	$rs = setup_php();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 51);

	print STDOUT "\t IspCP Apache main vhost file:";
	$rs = setup_httpd_main_vhost();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 38);

	print STDOUT "\t IspCP Apache awstats vhost file:";
	$rs = setup_awstats_vhost();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 41);

	print STDOUT "\t IspCP Postfix configuration files:";
	$rs = setup_mta();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 43);

	print STDOUT "\t IspCP Courier-Authentication:";
	$rs = setup_po();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 38);

	print STDOUT "\t IspCP Proftpd configuration file:";
	$rs = setup_ftpd();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 42);

	print STDOUT "\t IspCP Init scripts:";
	$rs = setup_ispcp_daemon_network();
	return $rs if ($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 28);

	push_el(\@main::el, 'rebuild_services_config()', 'Ending...');

	0;
}

# Rebuilding all gui related configuration files
sub rebuild_gui_cfg {

	push_el(\@main::el, 'rebuild_gui_cfg()', 'Starting...');

	my $rs = undef;

	print STDOUT "\t IspCP GUI named configuration:";
	$rs = setup_gui_named();
	return $rs if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 39);

	print STDOUT "\t IspCP GUI named fastCGI/php configuration:";
	$rs = setup_gui_php();
	return $rs if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 51);

	print STDOUT "\t IspCP GUI vhost file:";
	$rs = setup_gui_httpd();
	return $rs if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 30);

	print STDOUT "\t IspCP PMA configuration file:";
	$rs = setup_gui_pma();
	return $rs if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', 38);

	push_el(\@main::el, 'rebuild_gui_cfg()', 'Ending...');

	0;
}

# Rebuilding all customers configuration files
sub rebuild_customers_cfg {

	push_el(\@main::el, 'rebuild_customers_cfg()', 'Starting...');

	my ($rs, $rdata) = (undef, undef);

	# First, we reset db connection
	$main::db = undef;

	# Sets the dsn
	@main::db_connect = (
		"DBI:mysql:$main::db_name:$main::db_host",
		$main::db_user,
		$main::db_pwd
	);

	my $tables = {
		domain => 'domain_status',
		domain_aliasses => 'alias_status',
		subdomain => 'subdomain_status',
		subdomain_alias => 'subdomain_alias_status',
		mail_users => 'status',
		htaccess => 'status',
		htaccess_groups => 'status',
		htaccess_users => 'status'
	};

	# Set status as 'change'
	while (my ($table, $field) = each %$tables)
	{
		($rs, $rdata) = doSQL("UPDATE $table SET $field='change' WHERE $field='ok'");
		return $rs if ($rs != 0);
	}

	$main::db = undef;

	$rs = sys_command_rs("perl $main::cfg{'ROOT_DIR'}/engine/ispcp-rqst-mngr");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'rebuild_customers_cfg()', 'Ending...');

	0;
}

# Set engine and gui permissions
# TODO: Move it into ispcp-setup-methods.pl and call it into ispcp-setup
sub set_permissions {

	push_el(\@main::el, 'set_permissions()', 'Starting...');

	my ($rs, $cmd) = (undef, undef);

    my $lenght = 32;

	foreach(qw/engine gui/)
	{
		print STDOUT "\t Set $_ permissions:";
		$cmd = "$main::cfg{'CMD_SHELL'} $main::cfg{'ROOT_DIR'}/engine/setup/set-$_-permissions.sh &>/dev/null";
		$rs = sys_command_rs($cmd);
		return $rs if ($rs !=0);
		print STDOUT BOLD GREEN str_to_right('[done]', $lenght);
		$lenght = 29;
	}

	push_el(\@main::el, 'set_permissions()', 'Ending...');

	0;
}

#
# Format a string for it to be placed on the right
# of another string. The first string should not end
# with EOL.
#
# param: string $msg the message to be placed on right
# param: int $left_msg_lenght: lenght of left message
# return: string right formated message
#
sub str_to_right {

	my ($msg, $left_msg_lenght) = @_;

	my ($wchar) = GetTerminalSize();

	my $sep = ($wchar - $left_msg_lenght);

	return sprintf("%".$sep."s\n", $msg);
}

#
## Subroutines - End
#

#
## Main
#

update_startup();
update_engine();

# Should be modified
my $rs = setup_rkhunter();

if ($rs != 0) {
	my $el_data = pop_el(\@main::el);
	my ($sub_name, $msg) = split(/$main::el_sep/, $el_data);

	print STDERR "$msg\n";

	exit 1;
}

update_shutdown();

exit 0;
